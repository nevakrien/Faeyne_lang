use crate::lexer::{LexTag};
grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = ();

    enum LexTag {
        "name" => LexTag::Name,
        "atom" => LexTag::Atom,
        "string" => LexTag::String,
        "pstr" => LexTag::PoisonString,
        "UK" => LexTag::Unknowen,
    }
}

// Main rule to collect adjacent strings into a Vec<&'input str>
pub StringList: Vec<&'input str> = {
    // First case: handle the rest (add_on) first and prepend the current string
    <add_on:StringList> <current_start: @L> "string" <current_end: @R>  => {
        // First, handle the rest of the list
        let mut strings = add_on; // Start with the rest (add_on)

        // Prepend the current string
        strings.push(&input[current_start as usize..current_end as usize]);
        strings
    },

    // Second case: single string as the base case
    <current_start: @L> "string" <current_end: @R> => {
        let strings = vec![
            "THIS IS A STRING LIST", // Start with this string
            &input[current_start as usize..current_end as usize], // Add the current string
        ];

        strings
    },

    ! => {
        vec!["ERROR RECOVERY MODE"]
    }
};
