use crate::lexer::LexTag;
use crate::ast::{StringTable,Value,FunctionCall,FuncSig,FuncBlock,Statment};

grammar<'input>(input: &'input str, table: &mut StringTable<'input>);

extern {
    type Location = usize;
    type Error = ();

    // Enum definitions with lexer output for basic tokens
    enum LexTag {
        "pre_name" => LexTag::Name,
        "pre_atom" => LexTag::Atom,
        "pre_string" => LexTag::String,
        "pre_poison_str" => LexTag::PoisonString,
        "UK" => LexTag::Unknowen,

        // Keywords
        "import" => LexTag::Import,
        "def" => LexTag::FuncDec,
        "fn" => LexTag::Lambda,
        "return" => LexTag::Return,

        // Numbers
        "float" => LexTag::Float(<f64>),
        "int" => LexTag::Int(<Result<i64,f64>>),

        // Operators and others
        "." => LexTag::Dot,
        ";" => LexTag::Ender,
        "," => LexTag::Comma,

        "(" => LexTag::OpenParen,
        ")" => LexTag::CloseParen,
        "{" => LexTag::OpenCurly,
        "}" => LexTag::CloseCurly,
        "[" => LexTag::OpenSquare,
        "]" => LexTag::CloseSquare,
        "|" => LexTag::Pipe,

        "+" => LexTag::Plus,
        "-" => LexTag::Minus,
        "*" => LexTag::Mul,
        "/" => LexTag::Div,
        "div" => LexTag::IntDiv,
        "**" => LexTag::Pow,

        "%" => LexTag::Modolo,
        "&&" => LexTag::DoubleAnd,
        "||" => LexTag::DoubleOr,
        "^^" => LexTag::DoubleXor,

        "=" => LexTag::Eq,
        "==" => LexTag::DoubleEq,

        "<" => LexTag::Smaller,
        "<=" => LexTag::SmallerEq,
        ">" => LexTag::Bigger,

        "->" => LexTag::Arrow,
        "=>" => LexTag::SmallArrow,
    }
}

//basic types:

Atom: usize = {
    <start: @L> "pre_atom" <end: @R> => {
        table.get_id(&input[start..end])
    }
};

String: usize = {
    <start: @L> "pre_string" <end: @R> => {
        table.get_id(&input[start..end])
    }
};

PoisonString: usize = {
    <start: @L> "pre_poison_str" <end: @R> => {
        table.get_id(&input[start..end])
    }
};

Name: usize = {
    <start: @L> "pre_name" <end: @R> => {
        table.get_id(&input[start..end])
    }
};


//functions
pub FuncSig: FuncSig = {
    "def" <name:Name> <args:ArgList> => FuncSig{name, args},
};

ArgList: Vec<usize> = {
    "(" <args:CommaSepArgs> ")" => args,

    "(" ")" => vec![],
};

CommaSepArgs: Vec<usize> = {
    <args:CommaSepArgs> "," <arg:Name> => {
        let mut arguments = args;
        arguments.push(arg);
        arguments
    },
    
    <arg:Name> => vec![arg]
};

pub FuncCall: FunctionCall = {
    <name:Name> "(" <args:CommaSepValue> ")" => FunctionCall {
        name: name,
        args: args
    },
    <name:Name> "(" ")" => FunctionCall {
        name: name,
        args: vec![]
    }
};

CommaSepValue: Vec<Value> = {
    <args:CommaSepValue> "," <arg:Value> => {
        let mut arguments = args;
        arguments.push(arg);
        arguments
    },
    
    <arg:Value> => vec![arg],
};

//expressions
pub Value: Value = {
    <x:Name> => Value::Variable(x),
    <x:FuncCall> => Value::FuncCall(x),
    <x:"int"> => Value::Int(x),
    <x:"float"> => Value::Float(x),
};


Statment : Statment = {
    <func:FuncCall> ";" => Statment::Call(func),
    <n:Name> "=" <x:Value> ";" => Statment::Assign(n,x),
}

// Function block, with optional return statement
pub FuncBlock: FuncBlock = {
    "{" <body:Statements> <ret:Return> "}" => FuncBlock {
        body: body,
        ret: Some(ret),
    },

    "{" <body:Statements> "}" => FuncBlock {
        body: body,
        ret: None,
    },

    "{" <ret:Return> "}" => FuncBlock {
        body: vec![],
        ret: Some(ret),
    },

    "{" "}" => FuncBlock {
        body: vec![],
        ret: None,
    },
};


Statements: Vec<Statment> = {
    <stmts:Statements> <stmt:Statment> => {
        let mut statements = stmts;
        statements.push(stmt);
        statements
    },
    
    <stmt:Statment> => vec![stmt],
};

Return: Value = {
    "return" <val:Value> ";" => val,
    <val:Value> => val,
};
